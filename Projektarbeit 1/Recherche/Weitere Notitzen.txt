Util zitate The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when EMPHASIZED, are to be interpreted as described in [IETF RFC 2119]

Domain: Wissensgebiet/fachbereich auf dem man sich bewegt
  - Problemdomäne: Problemfeld/Einsatzbereich für Computersysteme/Software.

[https://www.w3schools.com/XML/xml_namespaces.asp]
XML Namespace:
- Name Conflicts: In XML, element names are defined by the developer. This often results in a conflict when trying to mix XML documents from different XML applications.
- Solving the Name Conflict Using a Prefix: Name conflicts in XML can easily be avoided using a name prefix. The namespace can be defined by an xmlns attribute in the start tag of an element (xmlns:prefix="namespaceURI").
- Default Namespaces: Defining a default namespace for an element saves us from using prefixes in all the child elements(xmlns="namespaceURI")
e.g. Prefix
<root xmlns:h="http://www.w3.org/TR/html4/" xmlns:f="https://www.w3schools.com/furniture">
  <h:table>
    <h:tr>
      <h:td>Apples</h:td>
      <h:td>Bananas</h:td>
    </h:tr>
  </h:table>
  <f:table>
    <f:name>African Coffee Table</f:name>
    <f:width>80</f:width>
    <f:length>120</f:length>
  </f:table>
</root>
e.g. default namespace
<root>
  <table xmlns="http://www.w3.org/TR/html4/">
    <tr>
      <td>Apples</td>
      <td>Bananas</td>
    </tr>
  </table>
  <table xmlns="https://www.w3schools.com/furniture">
    <name>African Coffee Table</name>
    <width>80</width>
    <length>120</length>
  </table> 
</root>

Formale Grammatik:
Eine Formale Grammatik wird dagestellt durch ein 4er Tupel aus non-Terminalsymbolen N, Alphabet Σ, Regelmenge P und Startsymbolen S. 
Mit einer formalen Grammatik lassen sich ausgehend von einem Startsymbol S (auch Startvariable genannt) Produktionsregeln aus einer Regelmenge P anwenden,
die aus dem Startsymbol neue Zeichenfolgen w (Wörter) erzeugen, welche wiederum weiter ersetzt werden können. Diesen Vorgang nennt man auch Ableitung.
Das Vokabular V einer Grammatik, bestehend aus der disjunkten Vereinigung eines Alphabets Σ von Terminalsymbolen mit einer Menge von non-terminalsymbolen N. 
V gibt dabei vor, welche Symbole dafür verwendet werden können. Die Menge der Terminalsymbole definiert, aus welchen Zeichen Wörter bestehen. Die Terminalsymbole können nicht weiter abgeleitet werden können.
Diese Wörter ergeben zusammengenommen die von der Grammatik beschriebene formale Sprache. Das Startsymbol muss dagegen ein Nichtterminalsymbol sein. Zusätzliche Nichtterminalsymbole erlauben differenziertere Regeln.
Produktionsregeln sind definitionsgemäß geordnete Paare ( α , β ), die auch α → β geschrieben werden. Man wendet sie auf eine Zeichenfolge w an, indem ein Vorkommen der Zeichenfolge α in w durch β ersetzt wird.
Auf der linken Seite der Regel muss immer mindestens ein Nichtterminalsymbol stehen.
Eine Menge von Regeln mit gleicher linker Seite, also α → β1 , … , α → βn, wird abkürzend auch als α → β1 | … | βn geschrieben.
Zum Beispiel kann man mit der Regelmenge X → + | −  die Zeichenfolge 1 X 2 entweder zu 1 + 2 oder zu 1 − 2 ableiten.

Legende der Grammatik: All sets are finite |set|<∞
G: Grammatik								G=(N,Σ,P,S)
V: Menge von Symbolen: Vokabular					Σ∪N
N: Menge von non-terminalsymbolen					N⊂V
Σ: Menge von terminalsymbolen: Alphabet 				Σ⊂V
S: Menge von Startsymbolen(bestimmte non-terminalsymbole)		S⊂N
P: Menge von Produktionsregeln						P=(Σ∪N)* N (Σ∪N)* → (Σ∪N)* 
Eine Produktion hat Zwei Seiten, auf der linken Seite muss mindestens ein non-Terminalsymbol stehen, vor und nach ihm können Terminal und non-Terminalsymbole stehen, auf der rechten Seite können Terminal und non-Terminalsymbole stehen

Darstellung
Terminalsymbole werden durch Kleinbuchstaben dargestellt.
Non-Terminalsymbole werden durch Großbuchstaben dargestellt.
Produktionenw werden durch Symbole → Symbole dargestellt

Strings
Formally, a string is a finite, ordered sequence of characters such as letters, digits or spaces.
The empty string ε or Λ or λ is of length zero, so there are no symbols in the string.

String length |w|
|w| returns the length of w. The length of a string are the amount of charachters in the string E.g. w=Hallo |w|=5
|w|ₐ returns the amount of the character a in w. E.g. w=Hallo |w|ₐ=1
String concatenation
is the operation of joining strings. e.g. w=Hallo w1=Welt ww1=HalloWelt
Joining the same string n times is written as wⁿ e.g. w=a w⁴=aaaa
Joining the same string 0 times is the empty string. w⁰=ε

Kleen Star *
The set V* can be described as the set of finite-length strings that can be generated by concatenating arbitrary elements of the set V, allowing the use of the same element multiple times or 0 times (=> contains ε).
e.g. V={a,b } V*={ε, a, b, aa, ab, ba, aaa, aab, aba, baa, bba, bab, bbb, ...}
V* without the empty string is denoted as V⁺. V⁺ = V* \ ε

Formale Sprache
Eine formale Sprache L(G) über einn Alphabet Σ, ist eine Teilmenge der Kleeneschen Hülle des Alphabets Σ*. 
L(G) ⊆ Σ*
Sprachen sind meistens durch ein bestimmtes Ersetzungsverfahren definiert(Regeln, wie die Alphabet-Zeichen kombiniert sein/werden dürfen)
Bei solchen Ersetzungsverfahren geht man Beispielsweise von einer spezifischen Start-Zeichenkette aus, die man durch wiederholte („rekursive“) Anwendung der Regeln (Text-Ersetzungen) schrittweise in Wortgebilde überführt,
die dann als ganzes, oder nur ein vorgegebener Abschnitt davon, als Wörter der Sprache gelten. Man redet hier auch von generativen Grammatiken.

Chomsky Hierachie
- Typ 0: Allgemeine Grammatik
  Definition: α → β; α ∈ V* \ Σ*; β ∈ V*
  Erklärung: α und β sind Worte aus Symbolen(terminal/non-terminal). D.h. Auf der linken Seite jeder Produktionsregel muss mindestens ein Nicht-Terminalsymbol steht.
- Typ 1: Kontext sensitive Grammatik
  Definition: α A β → α γ β; S → ε; A ∈ N; α,β ∈ V*; γ ∈ V⁺
  Erklärung: A ist ein non-terminales Symbol, α , γ , β sind Wörter bestehend aus Symbolen(terminal/non-terminal), wobei γ min 1 Symbol habe muss. D.h. Auf der linken Seite jeder Produktionsregel stehen weniger oder gleich viele Zeichen wie auf der Rechten
- Typ 2: Kontextfreie Grammatik
  Definition: A → α; A ∈ N; α ∈ V⁺
  Erklärung: A ist ein non-termiales Symbol, α ist ein Wort bestehend aus Symbolen(terminal/non-terminal), wobei α min 1 Symbol haben muss. D.h. Auf der linken Seite jeder Produktionsregel steht genau ein non-terminales Symbol und auf der rechten Seite steht eine beliebige nicht-leere Folge von Symbolen(terminal/non-terminal).
- Typ 3: (rechts)reguläre Grammatik
  Definition: A → αB; A → α; A → ε; A , B ∈ N; α ∈ T
  Erklärung: A, B ist ein terminales Symbol, α ist ein non-terminales Symbol. D.h. Auf der linken Seite jeder Produktionsregel steht genau ein non-terminales Symbol und auf der rechten genau ein terminales oder genau ein terminales gefolgt von genau einem non-terminalen

Beispiele für Chomsky Grammatiken:
G=(N,Σ,P,S); N={S,T,X}; Σ={a,b}; S={S}; 
Typ 0:
P={ST→a, S→ST, T→b}	e.g. S=>ST=>STb=>ab
Typ 1:
P={S→aTa | b, Ta→b}	e.g. S=>aTa=>ab
Typ 2:
P={S→aSa | b}		e.g. S=>aSa=>aaSaa=>aabaa
Typ 3:
P={S→aS | b}		e.g. S=>aS=>aaS=>aab

Computersprachen/Maschienenlesbare sprachen: sind formale Sprachen, die zur Interaktion zwischen Menschen und Computern entwickelt wurden.

domänenspezifische Sprache(DSL): Computersprache für ein bestimmtes Problemfeld. Sie soll alle Probleme der Domäne darstellen können und nichts darstellen, was außerhalb der Domäne liegt.

Auszeichnungssprachen: Computersprache, die Text und andere Daten mit Tags makiert und dadurch gliedert und formatiert.
Tags in Auszeichnungssprachen sind die Auszeichnungsmarken für elemente, welche den text einteilen. Ein Tag generell ist eine Auszeichnung eines Datnbestandes mit zusätzlichen Informationen
Syntax und Semantik der Auszeichnungssprache sind definiert durch:
1) Produktionsregeln einer Formalen Sprache(z.b. i.d. BNF)
2) Dokumententypdefinitionen
Man unterscheidet Auszeichnungen in:
- prozedurale Auszeichnung: Text provides instructions for programms that are to process the text. The instructions are processed sequentially form beginning to end
- darstellende/presentational Auszeichnung: gibt Information darüber, wie ein Text darzustellen ist z.B. <b>fett</b> oder <i>kursiv</i> 
  => explizite Formatierung der Darstellung
- beschreibende/descriptive Auszeichnung: gibt Semantische(verständniss/sinngebende) Informationen z.b. <title> </title> <p></p> <table></table>
  => implizite Formatierung der Darstellung => Vorteile:
    - Darstellung kann zentral festgelegt werden und typographisch hochwertig gemacht sein z.b. Latex
    - Anhand der reinen darstellung sind keine zusätzlichen Infos gewinnbar z.B. Anhand von fett/zentriert is nicht ablesbar ob es sich um einen Tabellen Header oder eine Überschrift handelt und somit die Gewichtung in einer Suche auch nicht
    - Cross Platform anzeige wird erleichtert.
Alternative usage:
Idea of markup language originated from textdocuments
Markup languages/data description languages are used for presentating all kind of information.
Those Languages are no programming languages, therefore they are more easily manipulated. E.g. web pages (HTML) can be embedded within other web pages, displayed when only partially received.

Dokumententypdefinition DTD: Satz an Regeln um Dokument eines bestimmten Typs zu deklarieren. Der Typ ist eine Klass ähnlicher Dokumente.
Die DTD definiert in Folge dessen die Dokumentenstruktur, also welche Elemente, Attribute, Entitäten, Notationen und Textblöcke es gibt.
=> Interpretieren dieser ist nicht aufgabe des DTD sondern des Parsers
- Textblöcke: werden in CDATA und PCDATA unterteilt.
  - CDATA: Character Data kennzeichnet einen ungeparsten textblock e.g. <movelet name="Dieser <Name> wird nicht geparsed">
  - PCDATA: Parsed Character kennzeichnet einen geparseten textblock, dieser wird syntaktisch vomm parser analysiert e.g. <text>dieser 'text' wird ohne '', dafür fett gezeigt</text>
- Elemente: Definiert welche Elemente im Dokumententyp vorkommen dürfen und was ihr möglicher inhalt ist
- Attribute: Defniert welche Elemente welche Attribute haben drfen. Für die Attribute wird name, typ, und vorgaben(required/implied/etc) festgelegt
- Entitäten: Bennante Abkürzung, die vom Parser durch ein Dokument oder eine Zeichenkette ersetzt wird e.g. &#39 in html wird mit ' ersetzt;
- Notationen: Hinweise zur Interpretation von externen Daten, die nicht direkt vom Parser verarbeitet werden können e.g. png als hinweis auf eine bilddatei

Token: ist eine Zeichenkette, der von einer formalen Grammatik ein Typ(Klasse) zugewiesen wird

Tokenizer: (auch lexikalischer Scanner, kurz Lexer) ist ein Computerprogramm zur Zerlegung von Plain text in Folgen von logisch zusammengehörigen Einheiten, so genannte Token

XML Documente werden intern als bäume behandelt es gibt 6 nodetypen:
- root node: oberster node im baum
Hängen als childnode über dem obrigen element
- element node: alle not root nodes in <element>
- text node: PCDATA in einem <element>text<element>
Hängen als gleichberechtigte node neben dem element, dass sie kommentieren
- comment node: <!-- comment -->
Hängen als Stammnode an ihrem element sind aber keine childnodes des elemnts
- attribute node: alle attribute in einem <element attribut=attrVal>
- namespace node: alle namespaces jeweils zum element
Er erkennt innerhalb der Eingabe Schlüsselwörter, Bezeichner, Operatoren und Konstanten. Diese bestehen aus mehreren Zeichen, bilden aber jeweils logische Einheiten, sogenannte Token => kann an einen parser weitergereichtwerden zur verarbeitung

RFC Request For Comments
    BCP: The IETF has endorsed a set of RFC's called Best Current Practices (BCP's).
    FYI: For Your Information (FYI) documents were created by Joyce Reynolds as a subset of the RFC's, with generally less technical and useful information with broad applicability to a wider audience
    IEN: Technical documents on a research project to design and build an Internet. RFC's called Internet Experiment Notes (IENs).
    RTR: Reseaux Associes pour la Recherche(=Association of European Research Networks), RFC's on the development of the European computer communications network.
    STD's. Standard (STD) documents are a subset of the RFC's, and are used to document full Internet standards.

Intertextualität:
Relation between atleast two media.
=> medium is shaped by another medium 
=> it is inevitable because all language refers to how it was used in the past(=intertextuality)
E.g. 2 Bücher beginnen mit dem ähnlichen Satz. Neo in Matrix soll einem weisen Hasen folgen ist eine Referenz auf Alice im Wunderland.

Term/Terminus: definierte Benennung für einen Begriff innerhalb der Fachsprache eines Fachgebietes.

Fuzzy Match: attempts to find a match which, although not a 100 percent match, is above the threshold matching percentage set by the application (Sucht ähnliche Strings)

Compiler:
Lexical Analysis: divides proramm text into tokens
Token: Tupel (tokenclass, string)
=> substrings of the programm need to be classified(=tokenized) according to their role(=token class)
e.g. for token classes:
- Identifier: string of letters or digits starting with a letter
- Integer: non empty string of digits
- Keyword: else, if, class, return, break, continue, etc.
- Whitespaces: non empty sequence of blanks newline and tabs
e.g. for tokenization
- foo=42 => (Identifier, "foo") (Operator, "=") (Integer, "42")
Lexical Analysis happens left to right => lookahead is sometimes required to resolve disambiguity e.g. = can be assignment operator or the 1st = of the compare operator ==
Regular Expression: entspricht inetwa der Produktionsregel einer Formalen Grammatik ohne möglichkeit der recursiven definition d.h. operatoren sind A+B, A*, AB
Meaningfunction L(x), x kann eine regular expression oder grammatik sein: Maps x(= syntax) to the set of strings produced by that syntax (=semantics)
=> several syntaxes can form 1 semanti => n to 1 => 1 to n is not possible because in that case it would be ambigious. because 1 syntax could produce different meanings

Parsing: Gets the tokens from the lexer and organises them in a parsetree using a context free grammar (non-terminal und terminale bilden die Nodes im parsetree)
Derivation: auflösung einer produktion durch ersetzung von links nach rechts (oder umgekehrt) 
=> Darstellung als baum: die root ist die start non-terminale, die children einer node sind die non-terminalen/terminalen, welche die non-terminale ersetzen
e.g. Prodrule: S => S'+'S | 5 | 4
konkrete ausprägung: 5+4+5
derivation: S=> S+S => 5+S => 5+S+S => 5+4+S => 5+4+5
parse tree:	S
	    S   +   S
	    5     S + S
		  4 + 5
Ambiguity: If a grammar has more than one parse tree for its right most or left most derivation for some string the grammar is amigious => this MUST NOT Happen
  => rewrite unambigous grammar
  => Enforce precedence of a parse tree over an other
More Info on how to implement parsing => Bottom Up Parsing SLR

Semantic analysis: understand meaning (this is very hard) => compilers do this very limited e.g. catching inconsistencysor unending loops
Optimization: Veränderung des Programms um es zu kürzen & effizienter zu machen e.g. x=y*0; => x=0;
Code generation: Translation of Code into another e.g. Java to javabytecode for the java virtual machine